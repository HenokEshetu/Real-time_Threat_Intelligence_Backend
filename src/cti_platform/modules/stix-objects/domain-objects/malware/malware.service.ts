import { Injectable, NotFoundException } from '@nestjs/common';
import { CreateMalwareInput, UpdateMalwareInput } from './malware.input';
import { Malware } from './malware.entity';
import { SearchMalwareInput } from './malware.resolver';
import { MalwareType } from '../../../../core/types/common-data-types';

@Injectable()
export class MalwareService {
  private mockMalware: Malware[] = [
    {
      id: 'malware--1111aaaa-2222-bbbb-3333-cccc4444dddd',
      type: 'malware',
      spec_version: '2.1',
      name: 'Emotet',
      description: 'A modular banking trojan.',
      malware_types: [MalwareType.TROJAN, MalwareType.UNKNOWN], // 'banker' is not in MalwareType, use UNKNOWN
      is_family: true,
      first_seen: new Date('2014-06-01T00:00:00Z'),
      last_seen: new Date('2021-01-27T00:00:00Z'),
      aliases: ['Geodo', 'Heodo'],
      labels: ['banking', 'modular'],
      confidence: 90,
      created: '2014-06-01T00:00:00Z',
      modified: '2021-01-27T00:00:00Z',
      created_by_ref: 'identity--malware-author',
      external_references: [
        {
          id: 'external-reference--mitre-attack-S0367',
          source_name: 'mitre-attack',
          external_id: 'S0367',
          url: 'https://attack.mitre.org/software/S0367/',
        },
      ],
      kill_chain_phases: [
        {
          id: 'kill-chain-phase--mitre-attack-initial-access',
          kill_chain_name: 'mitre-attack',
          phase_name: 'initial-access',
        },
      ],
    },
    {
      id: 'malware--5555eeee-6666-ffff-7777-gggg8888hhhh',
      type: 'malware',
      spec_version: '2.1',
      name: 'TrickBot',
      description: 'A banking trojan and malware dropper.',
      malware_types: [MalwareType.TROJAN, MalwareType.DROPPER],
      is_family: true,
      first_seen: new Date('2016-10-01T00:00:00Z'),
      last_seen: new Date('2022-03-15T00:00:00Z'),
      aliases: ['TrickLoader'],
      labels: ['banking', 'dropper'],
      confidence: 85,
      created: '2016-10-01T00:00:00Z',
      modified: '2022-03-15T00:00:00Z',
      created_by_ref: 'identity--malware-author',
      external_references: [],
      kill_chain_phases: [],
    },
    // ...add more mock malware if needed...
  ];

  async create(createMalwareInput: CreateMalwareInput): Promise<Malware> {
    const newMalware: Malware = {
      ...createMalwareInput,
      id: `malware--${Math.random().toString(36).substr(2, 16)}`,
      created: new Date().toISOString(),
      modified: new Date().toISOString(),
    };
    this.mockMalware.push(newMalware);
    return newMalware;
  }

  async findOne(id: string): Promise<Malware> {
    const malware = this.mockMalware.find((m) => m.id === id);
    if (!malware) throw new NotFoundException(`Malware with ID ${id} not found`);
    return malware;
  }

  async update(id: string, updateMalwareInput: UpdateMalwareInput): Promise<Malware> {
    const idx = this.mockMalware.findIndex((m) => m.id === id);
    if (idx === -1) throw new NotFoundException(`Malware with ID ${id} not found`);
    this.mockMalware[idx] = {
      ...this.mockMalware[idx],
      ...updateMalwareInput,
      modified: new Date().toISOString(),
    };
    return this.mockMalware[idx];
  }

  async remove(id: string): Promise<boolean> {
    const idx = this.mockMalware.findIndex((m) => m.id === id);
    if (idx === -1) return false;
    this.mockMalware.splice(idx, 1);
    return true;
  }

  async searchWithFilters(
    filters: SearchMalwareInput = {},
    page: number = 1,
    pageSize: number = 10
  ): Promise<{
    page: number;
    pageSize: number;
    total: number;
    totalPages: number;
    results: Malware[];
  }> {
    // For mock, ignore filters and just paginate
    const start = (page - 1) * pageSize;
    const results = this.mockMalware.slice(start, start + pageSize);
    const total = this.mockMalware.length;
    return {
      page,
      pageSize,
      total,
      totalPages: Math.ceil(total / pageSize),
      results,
    };
  }
}
